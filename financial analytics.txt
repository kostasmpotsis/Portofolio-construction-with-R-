==========================================================================
rm(list=ls(all=TRUE))

#install packages 
library(timeSeries)
install.packages("readxl")
library(readxl)
install.packages("tseries")
library(tseries)
install.packages("fGarch")
library(fGarch) 
install.packages("rugarch")
library(rugarch)
install.packages("Hmisc")
library(Hmisc)

#read the excel data firsth sheed USA _Fund_data
file.path='C:/Users/30695/Downloads/US_FUND_DATA.xlsx'
data <- read_excel(file.path)



dataUSA=data[536:672,72:160]
dim(dataUSA)

#read second sheed  factors  
file.path='C:/Users/30695/Downloads/US_FUND_DATA.xlsx'
factorsSP500 <- read_excel(file.path,sheet = 2)
head(factorsSP500)

length(Time)
dim(dataUSA)

Time <- seq(as.Date("2008-01-31")+1, as.Date("2019-06-28")+1, by="1 month")-1
Time <- timeLastDayInMonth(Time)
Data <- timeSeries(dataUSA, Time)


Time <- seq(as.Date("2013-12-31")+1, as.Date("2015-05-31")+1, by="1 month")-1
Time <- timeLastDayInMonth(Time)
factorSP500 <- timeSeries(factorsSP500[1:18,], Time)
factorSP500=factorSP500[,c(2:9)]
dim(Data)
dim(factorSP500)
Data=na.omit(Data)


T <- dim(Data)[1]
k <- dim(Data)[2]

#==========================================================================
  # Define In-sample period, Out-of-sample period, and Top Performing Funds
  #==========================================================================
outofsampleperiod=48          # Portfolio Construction (out of sample period
# 4 years )
insample=T-outofsampleperiod  # Estimation (in sample period)     
TopProp=0.2                   # proportion of top funds
PlithosTop=round(TopProp*k)   # number of top performing funds
#==========================================================================
options(max.print = 100000)
print(tbl_df(factorSP500), n=100000)

#==========================================================================
#  Define In-sample returns and out-of-sample returns and factors
#==========================================================================
Ret=Data[1:insample,]
dim(Ret)
Ret_outofsample=Data[(insample+1):T,]
dim(Ret_outofsample)
Fact=factorSP500
#[1:insample,]
dim(Fact)
#==========================================================================

dataUSA
#==========================================================================
#==========================================================================
#==========================     SHARPE RATIO   ============================
#==========================================================================
# Find the top performing fund based on SHARPE RATIO
# Invest in these top funds the next out-of-sample period
# There is not any rearangement in the portfolio
# The top funds could change every period 
m_vec = apply(Ret,2,mean)
var_vec = apply(Ret,2,var)
std_vec = sqrt(var_vec)
Sharpe_Ratio=m_vec/std_vec

SRsorted = sort(Sharpe_Ratio,index.return = TRUE)
Sharpe_Ratio_Sorted = SRsorted$x
I_Sharpe_Ratio_Sorted = SRsorted$ix
I_Sharpe_Ratio_Use = I_Sharpe_Ratio_Sorted[(k-PlithosTop+1):k]

matrix(I_Sharpe_Ratio_Use,2,9)


# Construct equally weighted portfolios based on SHARPE RATIO
returns_Sharpe_Ratio=Ret_outofsample[,I_Sharpe_Ratio_Use]
dim(returns_Sharpe_Ratio)
MR_Sharpe = apply(returns_Sharpe_Ratio,1,mean)
CR_Sharpe=cumsum(MR_Sharpe)
plot(CR_Sharpe, type="l",col='blue')
#==========================================================================
#==========================================================================
#==========================================================================

# Compute security betas (different for each fund)
betas<-NULL
for (i in 1:k) 
{
  y=Ret[,i]  
  x=Fact[,1]
  #k=Fact[,2]
  yres <- lm(y ~ x)
  beta <- coef(yres)[2]
  betas <- cbind(betas,beta)
}
betas




# Find the top performing fund based on TREYNOR RATIO
m_vec = apply(Ret,2,mean)
Treynor_Ratio=m_vec/betas

TRsorted = sort(Treynor_Ratio,index.return = TRUE)
Treynor_Ratio_Sorted = TRsorted$x
I_Treynor_Ratio_Sorted = TRsorted$ix
I_Treynor_Ratio_Use = I_Treynor_Ratio_Sorted[(k-PlithosTop+1):k]
matrix(I_Treynor_Ratio_Use,2,9)



# Construct equally weighted portfolios based on TREYNOR RATIO
returns_Treynor_Ratio = Ret_outofsample[,I_Treynor_Ratio_Use]
dim(returns_Treynor_Ratio)
MR_Treynor = apply(returns_Treynor_Ratio,1,mean)
CR_Treynor=cumsum(MR_Treynor)
plot(CR_Treynor, type="l",col='green')
#==========================================================================
#==========================    SORTINO RATIO   ============================
#==========================================================================
# Find the top performing fund based on SORTINO RATIO



# Find the top performing fund based on SORTINO RATIO
deltas<-NULL
for (i in 1:k) 
{
  y = Ret[,i]  
  mvalue = mean(y)
  minvec = NULL
  for (j in 1:length(y))
  {
    minvechelp = min(0,(y[j]-mvalue))
    minvec[j] = minvechelp
  }
  delta=sqrt(sum(minvec^2)/length(y))
  deltas <- cbind(deltas,delta)
}
deltas

m_vec = apply(Ret,2,mean)
Sortino_Ratio = m_vec/deltas
SOsorted = sort(Sortino_Ratio,index.return = TRUE)
SO_Sortino_Ratio_Sorted = SOsorted$x
I_Sortino_Ratio_Sorted = SOsorted$ix
I_Sortino_Ratio_Use = I_Sortino_Ratio_Sorted[(k-PlithosTop+1):k]
matrix(I_Sortino_Ratio_Use,2,9)


# Construct equally weighted portfolios based on SORTINO RATIO
returns_Sortino_Ratio = Ret_outofsample[,I_Sortino_Ratio_Use]
dim(returns_Sortino_Ratio)
MR_Sortino = apply(returns_Sortino_Ratio,1,mean)
CR_Sortino = cumsum(MR_Sortino)
plot(CR_Sortino, type="l")




















#==========================================================================
#===========================    JENSEN ALPHA   ============================
#==========================================================================
# Compute alphas from the Single index model (different for each fund)
alphas<-NULL
for (i in 1:k) 
{
  y=Ret[,i]  
  x=Fact[,1]
  yres <- lm(y ~ x)
  alpha <- coef(yres)[1]
  alphas <- cbind(alphas,alpha)
}
alphas

# Find the top performing fund based on JENSEN ALPHA
JAsorted = sort(alphas,index.return = TRUE)
Jensen_alpha_Sorted = JAsorted$x
I_Jensen_alpha_Sorted = JAsorted$ix
I_Jensen_alpha_Use = I_Jensen_alpha_Sorted[(k-PlithosTop+1):k]

# Construct equally weighted portfolios based on JENSEN ALPHA
returns_Jensen_alpha = Ret_outofsample[,I_Jensen_alpha_Use]
dim(returns_Jensen_alpha)
MR_Jensen = apply(returns_Jensen_alpha,1,mean)
CR_Jensen = cumsum(MR_Jensen)
plot(CR_Jensen, type="l",col="purple")
#Similarly is calculated the Jensen alpha based on multifactor models
#==========================================================================
#==========================================================================
#==========================================================================

#===========================    JENSEN ALPHA   ============================
#==========================================================================
# Compute alphas from the three factor  models (different for each fund)
alphas<-NULL
for (i in 1:k) 
{
  y=Ret[,i]  
  x=Fact[,c(1:3)]
  yres <- lm(y ~ x)
  alpha <- coef(yres)[1]
  alphas <- cbind(alphas,alpha)
}
alphas

# Find the top performing fund based on JENSEN ALPHA
JAsorted = sort(alphas,index.return = TRUE)
Jensen_alpha_Sorted = JAsorted$x
I_Jensen_alpha_Sorted = JAsorted$ix
I_Jensen_alpha_Use = I_Jensen_alpha_Sorted[(k-PlithosTop+1):k]

# Construct equally weighted portfolios based on JENSEN ALPHA
returns_Jensen_alpha = Ret_outofsample[,I_Jensen_alpha_Use]
dim(returns_Jensen_alpha)
MR_Jensen = apply(returns_Jensen_alpha,1,mean)
CR_Jensen = cumsum(MR_Jensen)
plot(CR_Jensen, type="l")

#Top performing funds
TopAssets <- data.frame(round(cbind(I_Sharpe_Ratio_Use, I_Treynor_Ratio_Use, I_Jensen_alpha_Use, I_Sortino_Ratio_Use), 2))
names(TopAssets) <- c("Sharpe", "Treynor", "Jensen", "Sortino")
TopAssets

Results= c(mean(MR_Sharpe),  sd(MR_Sharpe),  CR_Sharpe[outofsampleperiod],  mean(MR_Sharpe)/sd(MR_Sharpe), 
           mean(MR_Treynor),  sd(MR_Treynor),  CR_Treynor[outofsampleperiod], mean(MR_Treynor)/sd(MR_Treynor),
           mean(MR_Jensen),   sd(MR_Jensen),   CR_Jensen[outofsampleperiod],  mean(MR_Jensen)/sd(MR_Jensen),
           mean(MR_Sortino),  sd(MR_Sortino),  CR_Sortino[outofsampleperiod], mean(MR_Sortino)/sd(MR_Sortino)) 

Res <- matrix(Results, nrow = 4, ncol=4, byrow=TRUE)
Res

#Cumulative Returns
plot(CR_Sharpe, main="Cumulative Portfolio Returns", type="l", col="blue",ylab=NA,ylim=c(0,0.60))
lines(CR_Treynor, type="l", col="black")
lines(CR_Jensen, type="l", col="green")
lines(CR_Sortino, type="l", col="red")
legend("topleft",legend=c("Sharpe", "Treynor","Jensen","Sortino"),
       lty=c(1,1), pch=c(NA, 16), col=c("blue","black","green","red"))








##########multiple regrassion model and model selection#############
data5=data.frame(Ret,Fact)
# Initialize an empty list to store results
results_list <- list()

# Loop through the sequence and store the results in the list
for (i in seq(from = 1, to = 89, by = 1)) {
  # Fit the linear model using stepwise regression
  model <- step(lm(cbind(data5[, i]) ~ data5$Mkt.RF + data5$SMB + data5$HML +
                     data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR), trace = FALSE)$coefficients
  
  # Store the coefficients in the list
  results_list[[paste0("model_fund", i)]] <- model
}

###########run multiple regrassion##################
results_list2 <- list()
for (i in seq(from=1,to=89,by=1)){
MRres=lm(data5[,i]~ data5$Mkt.RF + data5$SMB + data5$HML +
     data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
n <- length(MRres$residuals)
significance_bound <- 1.96 / sqrt(n)
# Diagnostic tests for the residuals
# Autocorrelation of the residuals
acfplot=acf(MRres$residuals, 100)
pacf(MRres$residuals, 24)
if(any(acfplot$acf[2:18]>significance_bound|acfplot$acf[2:18]<(-significance_bound))){
  results_list2[[paste0('model',i)]] <- MRres
}
}
#some models have probelm need to fix with MA model the autocorelation 


results_list3 <- list()
for (i in seq(from=1,to=89,by=1)){
  MRres=lm(data5[,i]~ data5$Mkt.RF + data5$SMB + data5$HML +
             data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
  n <- length(MRres$residuals)
  significance_bound <- 1.96 / sqrt(n)
  # Diagnostic tests for the residuals
  # Autocorrelation of the residuals
  acf(MRres$residuals, 100)
  pacfplot=pacf(MRres$residuals, 24)
  if(any(pacfplot$acf[2:18]>significance_bound|pacfplot$acf[2:18]<(-significance_bound),na.rm=TRUE)){
    results_list3[[paste0('model',i)]] <- MRres
  }
}


results_list3 <- list()
for (i in seq(from=1,to=89,by=1)){
  MRres=lm(data5[,i]~ data5$Mkt.RF + data5$SMB + data5$HML +
             data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
  n <- length(MRres$residuals)
  significance_bound <- 1.96 / sqrt(n)
  # Diagnostic tests for the residuals
  # Autocorrelation of the residuals
  acf(MRres$residuals, 100)
  pacfplot=pacf(MRres$residuals^2, 24)
  if(any(pacfplot$acf[2:18]>significance_bound|pacfplot$acf[2:18]<(-significance_bound),na.rm=TRUE)){
    results_list3[[paste0('model',i)]] <- MRres
  }
}
#only model28 need garch errors to fix the heterodasky 


results_list3 <- list()
for (i in seq(from=1,to=89,by=1)){
  MRres=lm(data5[,i]~ data5$Mkt.RF + data5$SMB + data5$HML +
             data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
  n <- length(MRres$residuals)
  significance_bound <- 1.96 / sqrt(n)
  # Diagnostic tests for the residuals
  # Autocorrelation of the residuals
  acfplot=acf(MRres$residuals^2, 100)
  pacf(MRres$residuals^2, 24)
  if(any(acfplot$acf[2:18]>significance_bound|acfplot$acf[2:18]<(-significance_bound),na.rm=TRUE)){
    results_list3[[paste0('model',i)]] <- MRres
  }
}
#all the models are inside the confidence interval 

results_list3 <- list()
for (i in seq(from=1,to=89,by=1)){
  MRres=lm(data5[,i]~ data5$Mkt.RF + data5$SMB + data5$HML +
             data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
if(jarque.bera.test(MRres$residuals)$p.value<0.05){
  print(c("reject HO no normality errors",i))
}
}
#models 43 and 49 has no normal errors 
MRres=lm(data5[,43]~ data5$Mkt.RF + data5$SMB + data5$HML +
           data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
qqnorm(residuals(MRres)) 
qqline(residuals(MRres))
MRres=lm(data5[,49]~ data5$Mkt.RF + data5$SMB + data5$HML +
           data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
qqnorm(residuals(MRres)) 
qqline(residuals(MRres))


#to fix the errors for the 28th fund with garch model 
X<-matrix(cbind(data5$Mkt.RF,data5$SMB,data5$HML, 
                  data5$RMW,data5$CMA,data5$MOM,data5$BAB,data5$CAR),ncol=8)

spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder=c(1,1)), 
                   mean.model = list(armaOrder=c(0,0), include.mean = TRUE, external.regressors = X),
                   distribution.model = "norm")
spec
modelres <- ugarchfit(spec = spec, data = data5[,28])
modelres


#for the 28th fund 
head(data5[,28])
MRres=lm(data5[,28]~ data5$Mkt.RF + data5$SMB + data5$HML +
           data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
# Diagnostic tests for the residuals
# Autocorrelation of the residuals
pacf(MRres$residuals^2, 100)
modelres



#for the 2th fund check the autocorelation plot  
head(data5[,28])
MRres=lm(data5[,2]~ data5$Mkt.RF + data5$SMB + data5$HML +
           data5$RMW + data5$CMA + data5$MOM + data5$BAB + data5$CAR)
# Diagnostic tests for the residuals
# Autocorrelation of the residuals
acf(MRres$residuals, 100)
modelres
head(data5)



#==========================================================================
# Define In-sample period, Out-of-sample period, and Top Performing Funds
#==========================================================================
outofsampleperiod=48          # Portfolio Construction (out of sample period
# 4 years )
insample=T-outofsampleperiod  # Estimation (in sample period)     
TopProp=0.2                   # proportion of top funds
PlithosTop=round(TopProp*k)   # number of top performing funds
#==========================================================================
options(max.print = 100000)
print(tbl_df(factorSP500), n=100000)

#==========================================================================
#  Define In-sample returns and out-of-sample returns and factors
#==========================================================================

#[1:insample,]
dim(Fact)
#==========================================================================

dataUSA
T <- dim(Data)[1]
k <- dim(Data)[2]
outofsampleperiod <- 48
initialsample <- T-outofsampleperiod
targetreturn <- 0.009
#==========================================================================
#  Define In-sample returns and out-of-sample returns and factors
#==========================================================================
Ret=Data[1:insample,]
dim(Ret)
Ret_outofsample=Data[(insample+1):T,]
dim(Ret_outofsample)
Fact=factorSP500
Ret
#==========================================================================
# ITERATIVE PROCEDURE
#==========================================================================
# Empty matrices for the Results of MINIMUM VARIANCE PORTFOLIO
#calculate Cumulative Returns

# Initialize vectors/lists for storing results
keepPortWeights_static_MINVAR <- list()
Realized_Ret_static_MINVAR <- numeric()
keep_PortRisk_static_MINVAR <- numeric()
keep_CSR_static_MINVAR <- numeric()
keepPortWeights_static_MEANVAR <- list()
Realized_Ret_static_MEANVAR <- numeric()
keep_PortRisk_static_MEANVAR <- numeric()
keep_CSR_static_MEANVAR <- numeric()

# Set a regularization parameter
lambda <- 1e-4

# Start the out of sample performance of the models
keep_meanvec_static <- keep_covmat_static <- list()
for (i in 1:outofsampleperiod) {
  print(i)
  dataanalyse <- na.omit(Data[1:(initialsample-i+1),])
  
  # Calculate the corresponding mean and covariance matrices
  keep_meanvec_static[[i]] <- apply(dataanalyse, 2, mean, na.rm = TRUE)
  keep_covmat_static[[i]] <- cov(dataanalyse)
  m_vec <- keep_meanvec_static[[i]]
  cov_mat <- keep_covmat_static[[i]]
  
  # Regularize the covariance matrix
  cov_mat <- cov_mat + lambda * diag(k)
  
  #=====================================================================
  # Find optimal Minimum Variance portfolio
  #=====================================================================
  # Set matrices with constraints
  D.mat <- 2 * cov_mat
  d.vec <- rep(0, k)
  A.mat <- cbind(rep(1, k), diag(k))
  b.vec <- c(1, rep(0, k))
  
  # Solve the Quadratic Programming Problem
  qp.Result <- solve.QP(Dmat = D.mat, dvec = d.vec, Amat = A.mat, bvec = b.vec, meq = 1)
  x_static_MINVAR <- as.matrix(round(qp.Result$solution, 5), k, 1)
  
  # Keep portfolio weights across time
  keepPortWeights_static_MINVAR[[i]] <- x_static_MINVAR
  
  # Calculate Out of Sample Returns
  RR_static_MINVAR <- Data[initialsample + i, ] %*% x_static_MINVAR
  Realized_Ret_static_MINVAR[i] <- RR_static_MINVAR
  
  # Calculate Port Risk (portfolio standard deviation)
  PR_static_MINVAR <- sqrt(t(x_static_MINVAR) %*% cov_mat %*% x_static_MINVAR)
  keep_PortRisk_static_MINVAR[i] <- PR_static_MINVAR
  
  # Calculate Conditional Sharpe Ratio (CSR)
  CSR_static_MINVAR <- RR_static_MINVAR / PR_static_MINVAR
  keep_CSR_static_MINVAR[i] <- CSR_static_MINVAR
  
  #=====================================================================
  # Find optimal Mean Variance portfolio
  #=====================================================================
  # Set matrices with constraints
  D.mat <- 2 * cov_mat
  d.vec <- rep(0, k)
  A.mat <- cbind(rep(1, k), m_vec, diag(k))
  b.vec <- c(1, targetreturn, rep(0, k))
  
  # Solve the Quadratic Programming Problem
  qp.Result <- solve.QP(Dmat = D.mat, dvec = d.vec, Amat = A.mat, bvec = b.vec, meq = 1)
  x_static_MEANVAR <- as.matrix(round(qp.Result$solution, 5), k, 1)
  
  # Keep portfolio weights across time
  keepPortWeights_static_MEANVAR[[i]] <- x_static_MEANVAR
  
  # Calculate Out of Sample Returns
  RR_static_MEANVAR <- Data[initialsample + i, ] %*% x_static_MEANVAR
  Realized_Ret_static_MEANVAR[i] <- RR_static_MEANVAR
  
  # Calculate Port Risk (portfolio standard deviation)
  PR_static_MEANVAR <- sqrt(t(x_static_MEANVAR) %*% cov_mat %*% x_static_MEANVAR)
  keep_PortRisk_static_MEANVAR[i] <- PR_static_MEANVAR
  
  # Calculate Conditional Sharpe Ratio (CSR)
  CSR_static_MEANVAR <- RR_static_MEANVAR / PR_static_MEANVAR
  keep_CSR_static_MEANVAR[i] <- CSR_static_MEANVAR
}
# Cumulative Portfolio Returns
plot(Cum_Realized_Ret_static_MEANVAR, main="Cumulative Portfolio Returns", type="l", col="blue",ylab=NA)
lines(Cum_Realized_Ret_static_MINVAR, type="l", col="red")
legend("topleft",
       legend=c("MEANVAR", "MINVAR"),
       lty=c(1,1), pch=c(NA, 16), col=c("blue","red"))